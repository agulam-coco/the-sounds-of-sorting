package edu.grinnell.csc207.soundsofsorting.sorts;

import edu.grinnell.csc207.soundsofsorting.sortevents.CompareEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.SwapEvent;

import java.util.List;

import edu.grinnell.csc207.soundsofsorting.sortevents.SortEvent;
import java.util.ArrayList;

import java.util.Arrays;

/**
 * A collection of sorting algorithms.
 */
public class Sorts {

    /**
     * Sorts the array according to the bubble sort algorithm:
     * <pre>
     * [ unprocessed | i largest elements in order ]
     * </pre>
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> bubbleSort(T[] arr) {

        List<SortEvent<T>> events = new ArrayList<>();
        for (int i = arr.length; i > 0; i--) {
            for (int j = 0; j < i - 1; j++) {

                //log compare event
                events.add(new CompareEvent<>(j, j + 1));

                if (arr[j].compareTo(arr[j + 1]) > 0) {

                    events.add(new SwapEvent<>(j, j + 1));
                }
            }
        }
        return null;
    }

    /**
     * Sorts the array according to the selection sort algorithm:
     * <pre>
     * [ i smallest elements in order | unprocessed ]
     * </pre>
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> selectionSort(
            T[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int smallestIndex = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j].compareTo(arr[smallestIndex]) < 0) {
                    smallestIndex = j;
                }
            }

            //Do not waste resources if there is nothing to be done
            if (smallestIndex != i) {
                swap(arr, i, smallestIndex);
            }
        }

        return null;
    }

    /**
     * Sorts the array according to the insertion sort algorithm:
     * <pre>
     * [ i elements in order | unprocessed ]
     * </pre>
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> insertionSort(
            T[] arr) {
        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0; j--) {
                if (arr[j].compareTo(arr[j - 1]) < 0) {
                    swap(arr, j, j - 1);
                }
            }
        }
        return null;
    }

    /**
     * Sorts the array according to the merge sort algorithm.
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> mergeSort(
            T[] arr) {

        int low = 0;
        int high = arr.length - 1;

        T[] newArr = mergeSortRecursive(arr, low, high);

        System.arraycopy(newArr, 0, arr, 0, newArr.length);

        return null;
    }

    /**
     * Peforms recursive merge on an array With left and right halves sorted in
     * order
     *
     * @param <T> the carrier type of the array
     * @param arr1 the first array to merge
     * @param arr2 the second array to merge
     * @return a sorted array
     */
    public static <T extends Comparable<? super T>> T[] merge(T[] arr1, T[] arr2) {
        int leftCount = 0;
        int rightCount = 0;
        int newArraySize = 0;

        T[] returnArray = Arrays.copyOf(arr1, arr1.length + arr2.length);

        while (newArraySize < arr1.length + arr2.length) {
            if (leftCount < arr1.length && rightCount < arr2.length) {
                if (arr1[leftCount].compareTo(arr2[rightCount]) < 0) {
                    returnArray[newArraySize] = arr1[leftCount];
                    leftCount++;
                } else {
                    returnArray[newArraySize] = arr2[rightCount];
                    rightCount++;
                }
            } else if (leftCount < arr1.length) {
                returnArray[newArraySize] = arr1[leftCount];
                leftCount++;
            } else {
                returnArray[newArraySize] = arr2[rightCount];
                rightCount++;
            }
            newArraySize++;

        }
        System.out.println(Arrays.toString(returnArray));

        return returnArray;
    }

    /**
     * *
     * Recursive function that calls itself and repeatedly divides and conquers
     *
     * @param <T>
     * @param arr original arr
     * @param left left index of original arr
     * @param right right index of original arr
     * @return a sorted array
     */
    public static <T extends Comparable<? super T>> T[] mergeSortRecursive(T[] arr, int left, int right) {
        //base case 
        int mid = left + (right - left) / 2;

        if (left == right) {
            return Arrays.copyOfRange(arr, left, right + 1);
        }
        //sortleft
        T[] leftArray = mergeSortRecursive(arr, left, mid);

        //sortright
        T[] rightArray = mergeSortRecursive(arr, mid + 1, right);

        //sortMerge
        return merge(leftArray, rightArray);
    }

    /**
     * Sorts the array according to the quick sort algorithm.
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> quickSort(T[] arr) {
        int low = 0;
        int high = arr.length - 1;

        quickSortRecursive(arr, low, high);

        return null;
    }

    /**
     * Recursive function for quicksort
     *
     * @param <T>
     * @param arr
     * @param left value of sub arr
     * @param right value of sub arr
     */
    public static <T extends Comparable<? super T>> void quickSortRecursive(T[] arr, int left, int right) {
        if (left == right) {
            return;
        }

        int pivot = right;

        int i = left - 1;
        int j = left;

        while (j < right) {

            if (arr[j].compareTo(arr[pivot]) < 0) {
                i++;
                swap(arr, i, j);
            }
            j++;
        }

        //put pivot in correct position
        i++;
        swap(arr, i, j);
        pivot = i;

        //sort left of pivot
        if (pivot != left) {
            quickSortRecursive(arr, left, pivot - 1);
        }

        //sort right of pivot
        if (pivot != right) {
            quickSortRecursive(arr, pivot + 1, right);
        }

    }

    /**
     * Sorts the array according to the Tim Sort Algorithm
     *
     * @param <T>
     * @param arr
     * @return
     */
    //credit: https://www.youtube.com/watch?v=GhP5WbE4GYo
    //credit: https://en.wikipedia.org/wiki/Timsort
    public static <T extends Comparable<? super T>> List<SortEvent<T>> timSort(T[] arr) {
        int MIN_RUN_SIZE = 4;

        //selection sort each run 
        for (int start = 0; start < arr.length; start += MIN_RUN_SIZE) {
            int end = Math.min(arr.length - 1, start + MIN_RUN_SIZE - 1);
            timSortInsertion(arr, start, end);
        }

        //merge the sorted runs using merge
        for (int runSize = MIN_RUN_SIZE; runSize < arr.length; runSize *= MIN_RUN_SIZE) {
            for (int left = 0; left < arr.length; left += 2 * MIN_RUN_SIZE) {
                int mid = left + runSize - 1;
                int right = Math.min(left + 2 * runSize - 1, arr.length - 1);

                if (mid < right) {
                    timSortMerge(arr, left, mid, right);

                }
            }
        }
        return null;
    }

//    public static <T extends Comparable<? super T>> void timSortRecursive(T[] arr, int left, int right) {
//        //TO DO
//
//    }
    /**
     * Implementation of insertion sort for Tim Sort using Start and End indexes
     *
     * @param <T>
     * @param arr
     * @param start
     * @param end
     */
    public static <T extends Comparable<? super T>> void timSortInsertion(T[] arr, int start, int end) {
        for (int i = start; i <= end; i++) {
            for (int j = i; j > 0; j--) {
                if (arr[j].compareTo(arr[j - 1]) < 0) {
                    swap(arr, j, j - 1);
                }
            }
        }
    }

    /**
     * Implementation of the merge function for the tim sort algorithm
     *
     * @param <T>
     * @param arr
     * @param low
     * @param middle
     * @param high
     */
    //Credit: https://www.youtube.com/watch?v=U4g1dMry4W4
    public static <T extends Comparable<? super T>> void timSortMerge(T[] arr, int low, int middle, int high) {
        T[] leftArray = (T[]) new Comparable[middle - low + 1];
        T[] rightArray = (T[]) new Comparable[high - middle];

        System.arraycopy(arr, low, leftArray, 0, leftArray.length);
        System.arraycopy(arr, middle + 1, rightArray, 0, rightArray.length);

        int leftSubArrCounter = 0;
        int rightSubArrCounter = 0;
        int arrCounter = low;

        while (leftSubArrCounter < leftArray.length
                && rightSubArrCounter < rightArray.length) {
            arr[arrCounter++] = leftArray[leftSubArrCounter].compareTo(rightArray[rightSubArrCounter]) <= 0 ? leftArray[leftSubArrCounter++] : rightArray[rightSubArrCounter++];
        }

        while (leftSubArrCounter < leftArray.length) {
            arr[arrCounter++] = leftArray[leftSubArrCounter++];
        }

        while (rightSubArrCounter < rightArray.length) {
            arr[arrCounter++] = rightArray[rightSubArrCounter++];
        }

    }
}
