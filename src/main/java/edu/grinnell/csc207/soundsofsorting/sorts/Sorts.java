package edu.grinnell.csc207.soundsofsorting.sorts;

import edu.grinnell.csc207.soundsofsorting.sortevents.CompareEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.CopyEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.SwapEvent;

import java.util.List;

import edu.grinnell.csc207.soundsofsorting.sortevents.SortEvent;
import java.util.ArrayList;

import java.util.Arrays;

/**
 * A collection of sorting algorithms.
 */
public class Sorts {

    /**
     * Sorts the array according to the bubble sort algorithm:
     * <pre>
     * [ unprocessed | i largest elements in order ]
     * </pre>
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> bubbleSort(T[] arr) {

        List<SortEvent<T>> events = new ArrayList<>();

        for (int i = arr.length; i > 0; i--) {
            for (int j = 0; j < i - 1; j++) {

                //log compare event
                events.add(new CompareEvent<>(j, j + 1));

                if (arr[j].compareTo(arr[j + 1]) > 0) {
                    //log swap
                    events.add(new SwapEvent<T>(j, j + 1).apply(arr));
                }
            }
        }
        return events;
    }

    /**
     * Sorts the array according to the selection sort algorithm:
     * <pre>
     * [ i smallest elements in order | unprocessed ]
     * </pre>
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> selectionSort(
            T[] arr) {

        List<SortEvent<T>> events = new ArrayList<>();

        for (int i = 0; i < arr.length - 1; i++) {
            int smallestIndex = i;
            for (int j = i + 1; j < arr.length; j++) {

                //log compare event
                events.add(new CompareEvent<>(j, smallestIndex));
                if (arr[j].compareTo(arr[smallestIndex]) < 0) {
                    smallestIndex = j;
                }
            }

            //Do not waste resources if there is nothing to be done
            if (smallestIndex != i) {
                //log swap
                events.add(new SwapEvent<T>(i, smallestIndex).apply(arr));
            }
        }
        return events;
    }

    /**
     * Sorts the array according to the insertion sort algorithm:
     * <pre>
     * [ i elements in order | unprocessed ]
     * </pre>
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> insertionSort(
            T[] arr) {

        List<SortEvent<T>> events = new ArrayList<>();

        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0; j--) {
                //log compare event
                events.add(new CompareEvent<T>(j, j - 1).apply(arr));

                if (arr[j].compareTo(arr[j - 1]) < 0) {
                    //log swap
                    events.add(new SwapEvent<T>(j, j - 1).apply(arr));

                }
            }
        }
       return events;
    }

    /**
     * Sorts the array according to the merge sort algorithm.
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> mergeSort(
            T[] arr) {

        List<SortEvent<T>> events = new ArrayList<>();

        int low = 0;
        int high = arr.length - 1;

        mergeSortRecursive(arr, low, high, events);

        return events;
    }

    /**
     * Implementation of the merge function for the tim sort algorithm
     *
     * @param <T>
     * @param arr
     * @param low
     * @param middle
     * @param high
     * @param events
     */
    //Credit: https://www.youtube.com/watch?v=U4g1dMry4W4
    public static <T extends Comparable<? super T>> void merge(T[] arr, int low, int middle, int high, List<SortEvent<T>> events) {
        T[] leftArray = (T[]) new Comparable[middle - low + 1];
        T[] rightArray = (T[]) new Comparable[high - middle];

        System.arraycopy(arr, low, leftArray, 0, leftArray.length);
        System.arraycopy(arr, middle + 1, rightArray, 0, rightArray.length);

        int leftSubArrCounter = 0;
        int rightSubArrCounter = 0;
        int arrCounter = low;

        while (leftSubArrCounter < leftArray.length
                && rightSubArrCounter < rightArray.length) {

            //log compare event
            events.add(new CompareEvent<T>(low + leftSubArrCounter, middle + 1 + rightSubArrCounter).apply(arr));
            if (leftArray[leftSubArrCounter].compareTo(rightArray[rightSubArrCounter]) <= 0) {

                //log copy event
                events.add(new CopyEvent<T>(arrCounter++, low + leftSubArrCounter++).apply(arr));
                //arr[arrCounter++] = leftArray[leftSubArrCounter++];
            } else {
                //log copy event
                events.add(new CopyEvent<T>(arrCounter++, middle + 1 + rightSubArrCounter++).apply(arr));
                //arr[arrCounter++] = rightArray[rightSubArrCounter++];
            }
        }

        while (leftSubArrCounter < leftArray.length) {
            //log copy event
            events.add(new CopyEvent<T>(arrCounter++, low + leftSubArrCounter++).apply(arr));
            //arr[arrCounter++] = leftArray[leftSubArrCounter++];
        }

        while (rightSubArrCounter < rightArray.length) {
            //log copy event
            events.add(new CopyEvent<T>(arrCounter++, middle + 1 + rightSubArrCounter++).apply(arr));
            //arr[arrCounter++] = rightArray[rightSubArrCounter++];
        }

    }

//    /**
//     * Peforms recursive merge on an array With left and right halves sorted in
//     * order
//     *
//     * @param <T> the carrier type of the array
//     * @param arr1 the first array to merge
//     * @param arr2 the second array to merge
//     * @return a sorted array
//     */
//    public static <T extends Comparable<? super T>> T[] merge(T[] arr,int low,int  middle,int  high) {
//        int leftCount = 0;
//        int rightCount = 0;
//        int newArraySize = low;
//
//        T[] returnArray = Arrays.copyOf(arr1, arr1.length + arr2.length);
//
//        while (newArraySize < arr1.length + arr2.length) {
//            if (leftCount < arr1.length && rightCount < arr2.length) {
//                if (arr1[leftCount].compareTo(arr2[rightCount]) < 0) {
//                    returnArray[newArraySize] = arr1[leftCount];
//                    leftCount++;
//                } else {
//                    returnArray[newArraySize] = arr2[rightCount];
//                    rightCount++;
//                }
//            } else if (leftCount < arr1.length) {
//                returnArray[newArraySize] = arr1[leftCount];
//                leftCount++;
//            } else {
//                returnArray[newArraySize] = arr2[rightCount];
//                rightCount++;
//            }
//            newArraySize++;
//
//        }
//        System.out.println(Arrays.toString(returnArray));
//
//        return returnArray;
//    }
    /**
     * *
     * Recursive function that calls itself and repeatedly divides and conquers
     *
     * @param <T>
     * @param arr original arr
     * @param left left index of original arr
     * @param right right index of original arr
     * @return a sorted array
     */
    public static <T extends Comparable<? super T>> void mergeSortRecursive(T[] arr, int left, int right, List<SortEvent<T>> events) {
        //base case 
        int mid = left + (right - left) / 2;

        if (left == right) {
            return;
        }

        //sortleft
        mergeSortRecursive(arr, left, mid, events);

        //sortright
        mergeSortRecursive(arr, mid + 1, right, events);

        //sortMerge
        merge(arr, left, mid, right, events);
    }

    /**
     * Sorts the array according to the quick sort algorithm.
     *
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> quickSort(T[] arr) {
        List<SortEvent<T>> events = new ArrayList<>();

        int low = 0;
        int high = arr.length - 1;

        quickSortRecursive(arr, low, high, events);

        return events;
    }

    /**
     * Recursive function for quicksort
     *
     * @param <T>
     * @param arr
     * @param left value of sub arr
     * @param right value of sub arr
     * @param events list of events done by function
     */
    public static <T extends Comparable<? super T>> void quickSortRecursive(T[] arr, int left, int right, List<SortEvent<T>> events) {
        if (left == right) {
            return;
        }

        int pivot = right;

        int i = left - 1;
        int j = left;

        while (j < right) {
            //log compare event
            events.add(new CompareEvent<T>(j, pivot).apply(arr));

            if (arr[j].compareTo(arr[pivot]) < 0) {
                i++;

                //log swap
                events.add(new SwapEvent<T>(i, j).apply(arr));

            }
            j++;
        }

        //put pivot in correct position
        i++;
        //log swap
        events.add(new SwapEvent<T>(i, j).apply(arr));
        pivot = i;

        //sort left of pivot
        if (pivot != left) {
            quickSortRecursive(arr, left, pivot - 1, events);
        }

        //sort right of pivot
        if (pivot != right) {
            quickSortRecursive(arr, pivot + 1, right, events);
        }

    }

    /**
     * Sorts the array according to the Tim Sort Algorithm
     *
     * @param <T>
     * @param arr
     * @return
     */
    //credit: https://www.youtube.com/watch?v=GhP5WbE4GYo
    //credit: https://en.wikipedia.org/wiki/Timsort
    public static <T extends Comparable<? super T>> List<SortEvent<T>> timSort(T[] arr) {
        List<SortEvent<T>> events = new ArrayList<>();

        int MIN_RUN_SIZE = 4;

        //selection sort each run 
        for (int start = 0; start < arr.length; start += MIN_RUN_SIZE) {
            int end = Math.min(arr.length - 1, start + MIN_RUN_SIZE - 1);
            timSortInsertion(arr, start, end, events);
        }

        //merge the sorted runs using merge
        for (int runSize = MIN_RUN_SIZE; runSize < arr.length; runSize *= MIN_RUN_SIZE) {
            for (int left = 0; left < arr.length; left += 2 * MIN_RUN_SIZE) {
                int mid = left + runSize - 1;
                int right = Math.min(left + 2 * runSize - 1, arr.length - 1);

                if (mid < right) {
                    merge(arr, left, mid, right, events);

                }
            }
        }
        return events;
    }

//    public static <T extends Comparable<? super T>> void timSortRecursive(T[] arr, int left, int right) {
//        //TO DO
//
//    }
    /**
     * Implementation of insertion sort for Tim Sort using Start and End indexes
     *
     * @param <T>
     * @param arr
     * @param start
     * @param end
     * @param events
     */
    public static <T extends Comparable<? super T>> void timSortInsertion(T[] arr, int start, int end, List<SortEvent<T>> events) {
        for (int i = start; i <= end; i++) {
            for (int j = i; j > 0; j--) {
                //log compare event
                events.add(new CompareEvent<T>(j, j - 1).apply(arr));

                if (arr[j].compareTo(arr[j - 1]) < 0) {
                    //log swap
                    events.add(new SwapEvent<T>(j, j - 1).apply(arr));
                }
            }
        }
    }

//    /**
//     * Implementation of the merge function for the tim sort algorithm
//     *
//     * @param <T>
//     * @param arr
//     * @param low
//     * @param middle
//     * @param high
//     * @param events
//     */
//    //Credit: https://www.youtube.com/watch?v=U4g1dMry4W4
//    public static <T extends Comparable<? super T>> void timSortMerge(T[] arr, int low, int middle, int high, List<SortEvent<T>> events) {
//        T[] leftArray = (T[]) new Comparable[middle - low + 1];
//        T[] rightArray = (T[]) new Comparable[high - middle];
//
//        System.arraycopy(arr, low, leftArray, 0, leftArray.length);
//        System.arraycopy(arr, middle + 1, rightArray, 0, rightArray.length);
//
//        int leftSubArrCounter = 0;
//        int rightSubArrCounter = 0;
//        int arrCounter = low;
//
//        while (leftSubArrCounter < leftArray.length
//                && rightSubArrCounter < rightArray.length) {
//
//            //log compare event
//            events.add(new CompareEvent<>(low + leftSubArrCounter, middle + 1 + rightSubArrCounter));
//            if (leftArray[leftSubArrCounter].compareTo(rightArray[rightSubArrCounter]) <= 0) {
//
//                //log copy event
//                events.add(new CopyEvent<>(arrCounter++, low + leftSubArrCounter++));
//                //arr[arrCounter++] = leftArray[leftSubArrCounter++];
//            } else {
//                //log copy event
//                events.add(new CopyEvent<>(arrCounter++, middle + 1 + rightSubArrCounter++));
//                //arr[arrCounter++] = rightArray[rightSubArrCounter++];
//            }
//        }
//
//        while (leftSubArrCounter < leftArray.length) {
//            //log copy event
//            events.add(new CopyEvent<>(arrCounter++, low + leftSubArrCounter++));
//            //arr[arrCounter++] = leftArray[leftSubArrCounter++];
//        }
//
//        while (rightSubArrCounter < rightArray.length) {
//            //log copy event
//            events.add(new CopyEvent<>(arrCounter++, middle + 1 + rightSubArrCounter++));
//            // arr[arrCounter++] = rightArray[rightSubArrCounter++];
//        }
//
//    }
    /**
     * Applies all events to array in order
     *
     * @param <T>
     * @param l array list of T[] type
     * @param events list of events to be executed
     */
    public static <T> void eventSort(T[] l, List<SortEvent<T>> events) {

        for (SortEvent event : events) {
            event.apply(l);
        }
    }
}
